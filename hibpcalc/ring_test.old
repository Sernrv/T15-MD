# -*- coding: utf-8 -*-
"""
Created on Wed Apr 12 13:15:57 2023

@author: reonid
"""

import sys
hibplib_path = 'C:\\reonid\\reonid-packages'
if hibplib_path not in sys.path: sys.path.append(hibplib_path)

import numpy as np

from joblib import Parallel, delayed
import multiprocessing as mp


import matplotlib.pyplot as plt
import math as math
#import types as types

import reometry.geom3d as g3
import reometry.geomx as gx

from ring import Ring, magneticFdOnRingCenter, magneticFdOfRing #, FilamentGroup
from geomfunc import pt3D, vec3D

import misc

SI_mu0 = 4*np.pi*1e-7

sin = np.sin
cos = np.cos  # ??? math
atan2 = math.atan2

sin = math.sin
cos = math.cos  # ??? math

EPS_WIRE = 0.05 # m

def calc_Bpoint(r, IdL, r_elem):
    r2 = r - r_elem
    r25 = np.linalg.norm(r2, axis=1)
    # create a mask to exclude points close to wire
    mask = (r25 < EPS_WIRE)  # 0.6 is ok for plasma current field
    r25 = r25**3
    r3 = r2 / r25 [:, np.newaxis]

    cr = np.cross(IdL, r3)
    cr[mask] = [0., 0., 0.]

    # claculate sum of contributions from all current elements
    s = np.sum(cr, axis=0)
    return s #*1e-7

def biot_savart(points, wires):
    '''
    calculate the magnetic field generated by currents flowing through wires
    :param wires: list of wire objects
    :param points: numpy array with x,y,z coordinates of n points
    :return: numpy array of n vectors representing the B field at given points
    '''
    if len(wires) == 0:  return np.nan
    if len(points) == 0: return np.nan

    c = 0
    # generate list of IdL and r1 vectors from all wires
    for w in wires:
        c += 1
        _IdL, _r1 = w.IdL_r1()
#        print('wire {} has {} segments'.format(c, len(_IdL)))
        if c == 1:
            IdL = _IdL
            r1 = _r1
        else:
            IdL = np.vstack((IdL, _IdL))
            r1 = np.vstack((r1, _r1))

    # now we have all segment vectors multiplied by the flowing current in IdL
    # and all vectors to the central points of the segments in r1
    
    # calculate vector B*1e7 for each point in space
    # calculate B at each point r

    # single processor
    # B = np.array([calc_Bpoint(r, IdL, r1) * 1e-7 for r in points])

    # multiprocessing
    n_workers = mp.cpu_count() - 1
    s = Parallel(n_jobs=n_workers)(delayed(calc_Bpoint)(r, IdL, r1) for r in points)
    B = np.array(s)*1e-7

    return B



class TestWire: 
    def __init__(self, path, I): 
        self.I = I
        self.path = path
        self.close_path()       

    def close_path(self):
        pass
        if not np.all(self.path[-1] == self.path[0]): 
            self.path = np.append(self.path, self.path[0:1], axis=0)

    @property
    def IdL_r1(self):
        '''
        calculate discretized path elements dL and their center point r1
        :return: numpy array with I * dL vectors, numpy array of r1 vectors 
        (center point of element dL)
        '''
        N = len(self.path)
        if N < 2:
            raise Exception("discretized path must have at least two points")

        IdL = np.array([self.path[c+1] - self.path[c] for c in range(N-1)]) * self.I
        r1 = np.array([(self.path[c+1] + self.path[c])*0.5 for c in range(N-1)])

        return IdL, r1

    
    def calcB(self, r): 
        b = np.zeros(3)
        IdL, r1 = self.IdL_r1
        for idl, rw in zip(IdL, r1): 
            b += calc_Bpoint(r.reshape(1, 3), idl, rw)
        return b*1e-7
    
    def calcB_(self, r): 
        b = np.zeros(3)
        IdL, r1 = self.IdL_r1
        b = biot_savart(r.reshape(1, 3), [self])
        return b
    
    
    def plot(self): 
        xx = self.path[:, 0]
        yy = self.path[:, 1]
        plt.plot(xx, yy)


def line_array(pt0, pt1, N): 
    result = np.zeros( (N, 3) )
    #line = g3.Line3D(pt0, pt1 - pt0)
    for i in range(N):  
        result[i, :] = pt0 + (pt1 - pt0)*i/(N-1)
    return result



J = 1.0  # A 
r = 1.0  # m 

# B fiels on the center
B0 =  magneticFdOnRingCenter(J, r)
B0 = np.array([0.0, 0.0, B0]) 
_B0 = magneticFdOfRing(pt3D(0.0, 0, 0), J, pt3D(0, 0, 0), r, vec3D(0, 0, 1)) * 1e-6 # !!!

if not all( np.isclose(B0, _B0, 1e-8)  ): 
    print('TEST FAILED: B in the center of the ring', B0, _B0)


circle = g3.Circle3D(center=pt3D(0, 0, 0), radius=1.0, normal=vec3D(0, 0, 1))
ring = Ring(circle.center, circle.radius, circle.normal, 1.0, 0.05)

pgn = circle.getPolygon(100)
w = TestWire(np.array(pgn.points), 1.0)
#ring.plot()
#w.plot()


probing_line = line_array(pt3D(-2.0, 0.90, 13.4), pt3D(2.0, 0.90, 13.4), 1000)


#%% test distance 
def gen_dist_from_poligon():     
    pgn = circle.getPolygon(30)
    for p in probing_line: 
        #yield ring.distance(p) 
        yield gx.distFromPolygon(p, pgn)

def gen_dist_from_ring():     
    #pgn = circle.getPolygon(100)
    for p in probing_line: 
        yield ring.distance(p) 
        #yield gx.distFromPolygon(p, pgn)

for d, _d in zip(gen_dist_from_ring(), gen_dist_from_poligon()): 
    if not np.isclose(d, _d, 1e-4): 
        print('TEST FAILED: distance from ring', d, _d)


#plt.plot(probing_line[:, 0], list(gen_dist_from_ring()) )
#plt.plot(probing_line[:, 0], list(gen_dist_from_poligon()) )

 
#%%  B test: integration and analitical formula

pgn = circle.getPolygon(1000) # 100 is not enough for comparison with analitical solution
w = TestWire(np.array(pgn.points), 1.0)
ring.wire_radius = 0.05
    
if True: 
    
    #points = [np.random.rand(3)*1.5 for _ in range(1000000)]     
    points = np.random.rand(1000000, 3)*3.0 - 1.5
    
    for i in range(1000):
        r = points[i]
        if ring.distance(r) < ring.wire_radius: 
            continue  # disagreement by design
        B = ring.calcB(r)
        _B = w.calcB(r)
        if not all( np.isclose(B, _B, rtol=1e-6) ): 
             print('TEST FAILED: B_ring != B_wire', B, _B, r)


#%% performance test: integration and analitical formula

if True: 

    pgn = circle.getPolygon(100) # 1000 is too slow
    w = TestWire(np.array(pgn.points), 1.0)
    
    with misc.StopWatch('ring 200000'): 
        for i in range(200000):
            r = points[i]
            B = ring.calcB(r)

    with misc.StopWatch('wire 1000  '): 
        for i in range(1000):
            r = points[i]
            _B = w.calcB(r)

#%% performance test: Parallel

if True:      
    with misc.StopWatch('parallel ring 200000'): 
        n_workers = mp.cpu_count() - 1
        s = Parallel(n_jobs=n_workers)(delayed(ring.calcB)(r) for r in points[:200000])
        
        # !!! 2.5 times worse !!!
        